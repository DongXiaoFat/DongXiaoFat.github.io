<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://dongxiaofat.github.io/</id><title>SunMoon</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-02-26T16:56:27+08:00</updated> <author> <name>DongXiaoFat</name> <uri>https://dongxiaofat.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://dongxiaofat.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://dongxiaofat.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 DongXiaoFat </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>深入理解SystemServer启动</title><link href="https://dongxiaofat.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SystemServer%E5%90%AF%E5%8A%A8/" rel="alternate" type="text/html" title="深入理解SystemServer启动" /><published>2021-02-26T13:45:00+08:00</published> <updated>2021-02-26T13:45:00+08:00</updated> <id>https://dongxiaofat.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SystemServer%E5%90%AF%E5%8A%A8/</id> <content src="https://dongxiaofat.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SystemServer%E5%90%AF%E5%8A%A8/" /> <author> <name>DongXiaoFat</name> </author> <category term="Android" /> <category term="Framework" /> <summary> 深入理解SystemServer启动 SystemServer 进程是我们Android系统中重中之重的一个进程服务，Android中重要的Service几乎都是有它管理运行，从《深入理解Zygote启动》一文中，我们知道了，SystemServer是由Zygote进程进行fork出来，其Binder线程是由 ZygoteInit 进行创建，第一个函数入口是SystemServer.java 里的main 函数。 1. SystemServer 入口——main 1.1 SystemServer 对象构造 首先通过查询SYSPROP_START_COUNT当前启动的次数+1. 在systemserver被创建的时候首先会去通过SystemClock.elapsedRealtime()和SystemClock.uptimeMillis()计算系统启动到... </summary> </entry> <entry><title>SurfaceFlinger 之 HWComposer</title><link href="https://dongxiaofat.github.io/posts/SurfaceFlinger-HWComposer/" rel="alternate" type="text/html" title="SurfaceFlinger 之 HWComposer" /><published>2021-02-26T12:45:00+08:00</published> <updated>2021-02-26T12:45:00+08:00</updated> <id>https://dongxiaofat.github.io/posts/SurfaceFlinger-HWComposer/</id> <content src="https://dongxiaofat.github.io/posts/SurfaceFlinger-HWComposer/" /> <author> <name>DongXiaoFat</name> </author> <category term="Android" /> <category term="Framework" /> <summary> SurfaceFlinger 之 HWComposer HWC（hwcomposer）是Android中进行窗口（Layer）合成和显示的HAL层模块，其实现是特定于设备的，而且通常由显示设备制造商 (OEM)完成，为SurfaceFlinger服务提供硬件支持。 SurfaceFlinger可以使用OpenGL ES合成Layer，这需要占用并消耗GPU资源。大多数GPU都没有针对图层合成进行优化，当SurfaceFlinger通过GPU合成图层时，应用程序无法使用GPU进行自己的渲染。而HWC通过硬件设备进行图层合成，可以减轻GPU的合成压力。 HWComposer 与 SurfaceFlinger的联系 在 SurfaceFlinger 进行init的时候会去获取HWComposer实例，而这份实例是由SurfaceFlingerFactory 根... </summary> </entry> <entry><title>Android OOM Low Memory Killer 机制</title><link href="https://dongxiaofat.github.io/posts/Android-oom-adj/" rel="alternate" type="text/html" title="Android OOM Low Memory Killer 机制" /><published>2021-02-26T08:45:00+08:00</published> <updated>2021-02-26T08:45:00+08:00</updated> <id>https://dongxiaofat.github.io/posts/Android-oom-adj/</id> <content src="https://dongxiaofat.github.io/posts/Android-oom-adj/" /> <author> <name>DongXiaoFat</name> </author> <category term="Android" /> <category term="Framework" /> <summary> Android OOM Low Memory Killer 机制 本文主要介绍Android的low memory killer的 oom_adj的相关概念，以及根据一些案例来阐述了解oom_adj对于做Android应用开发的重要意义。 1. Low Memory Killer中进程的分类以及各类进程的adj值 在Android的low memroy killer机制中，会对于所有进程进行分类，对于每一类进程会有其oom_adj值的取值范围，oom_adj值越高则代表进程越不重要，在系统执行低杀操作时，会从oom_adj值越高的开始杀。系统low memeory killer机制下对于进程的级别的以变量的形式定义在framework/base/core/java/com/android/server/am/ProcessList.java类中，可总结成下表： ... </summary> </entry> <entry><title>深入理解 AndroidFramework 之 Zygote 启动</title><link href="https://dongxiaofat.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Zygote-%E5%90%AF%E5%8A%A8/" rel="alternate" type="text/html" title="深入理解 AndroidFramework 之 Zygote 启动" /><published>2021-02-25T20:45:00+08:00</published> <updated>2021-02-25T20:45:00+08:00</updated> <id>https://dongxiaofat.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Zygote-%E5%90%AF%E5%8A%A8/</id> <content src="https://dongxiaofat.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Zygote-%E5%90%AF%E5%8A%A8/" /> <author> <name>DongXiaoFat</name> </author> <category term="Android" /> <category term="Framework" /> <summary> 深入理解 AndroidFramework 之 Zygote 启动 Zygote 作为Android 第一个出道的进程被广大网友所熟知，那么该进程是如何被加载，如何运行的呢？在这里我们就尝试将她神秘的面纱一层层揭开。 1. Init 进程 Linux中PID为0的进程是所有其他进程的祖先, 也称作idle进程或swapper进程，在系统初始化时由kernel自身从无到有创建。进程0的数据成员大部分是静态定义的。 在Android系统中 0号进程会孵化出2个核心进程，一个进程号为2的名为kthreadd的进程，另一个则是进程号为1名为init的进程。kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理，所有的内核线程都是直接或者间接的以kthreadd为父进程。Init 进程是负责解析并执行... </summary> </entry> <entry><title>深入理解Android Font 机制</title><link href="https://dongxiaofat.github.io/posts/AndroidFont/" rel="alternate" type="text/html" title="深入理解Android Font 机制" /><published>2021-02-16T16:30:00+08:00</published> <updated>2021-02-16T16:30:00+08:00</updated> <id>https://dongxiaofat.github.io/posts/AndroidFont/</id> <content src="https://dongxiaofat.github.io/posts/AndroidFont/" /> <author> <name>DongXiaoFat</name> </author> <category term="Android" /> <category term="Framework" /> <summary> 深入理解Android Font 机制 Android 字体是由配置好的ttf字体文件来描述的，然而在字体加载的过程中首先就是根据字符去匹配相应的ttf文件，然后在该ttf文件中依照Unicode编码查找字符形状进行描绘。 Unicode编码 Unicode 规范规定，使用U+前缀加上一个十六进制的整数表示一个字符，比如U+0041表示大写拉丁字母A。而整个Unicode的字符集，需要U+000000到U+10FFFF的存储空间，一共使用了21bit共有17*2^16个位置。从U+000000到U+10FFFF,unicod的编码空间可以被划分为17个平面（plane），每个平面包含2^16个码位。17个平面的码位就可以表示为U+xx0000到U+xxFFFF,其中xx表示0x00-0X10,共17个平面。第一个平面称之基本多语言平面（Basic Multilingual... </summary> </entry> </feed>
